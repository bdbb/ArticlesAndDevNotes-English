# [Minecraft] Using Computer Programs to Simulate and Analyze Kelp Growth Patterns
*Initially, I just wanted to use this research to learn more Python skills, such as getting familiar with matplotlib, numpy, and other modules for future study and work. I originally thought this would be a simple task that could be easily completed in a few hours each afternoon. However, from when I truly started development to when this article began being written, more than ten days had passed, and this research project had become a hodgepodge of two languages, multi-threading/processing, and GPU-accelerated computing. Besides presenting some research results, writing this article is also a simple record of my current state.*

## Part 0 - Prior Research, Acknowledgments, and Conclusions Guide
- Prior Research
  - Redberd小红 used MATLAB in [cv12778288](https://www.bilibili.com/read/cv12778288) to graph and analyze kelp growth height.
  - 肥啾U_ruby, 镍镍, and others derived the efficiency formula for individual kelp through mathematical calculations. The research is recorded in [cv12830269](https://www.bilibili.com/read/cv12830269)

- Special Thanks:
  - TokiNoBug (Bilibili ID: 窃梦家) and others for using mathematical calculations to optimize production machines in Minecraft
  - 肥啾U_ruby, menggui233, redberd小红, 镍镍, and others for their pioneering research on kelp farm calculations
  - ishland for writing the GPU-accelerated simulation program for this project, making high-precision kelp growth simulation possible within acceptable time
  - Dreamily854 for sharing their home server computing resources with me and ishland
  - Many players in TIS Lab and OSTC Lab for valuable discussions

- Conclusions Guide:
  - Conclusions are at the end of this article, just scroll down quickly

## Part 1 - Known Information and Existing Problems
- The relevant mechanics involved in kelp farming can be summarized as follows:
    - In Minecraft Java Edition, during each game tick, chunks with a loading level of 31 or below and whose center is within 128 blocks horizontally from the nearest player will execute random ticks. (Source: Minecraft Chinese Wiki - Tick#Random Tick)
    - For each chunk executing random ticks, processing occurs by subchunk (also called section, size 16×16×16 blocks), from bottom to top. Each subchunk selects randomTickSpeed (game rule - random tick speed, default 3) blocks to calculate corresponding random ticks, regardless of whether the random tick execution succeeds or whether selected blocks repeat.
    - Only kelp tips (blocks with data value kelp) receive random ticks. Other parts of kelp (kelp_plant) do nothing when receiving random ticks.
    - When kelp tips receive a random tick, there's a 14% probability to grow one segment. Growth occurs by changing its current position to kelp_plant, and the water block above (flowing down or water source) becomes kelp. Execution timing is at the moment of random tick hit.
    - kelp blocks have an age state. Each growth increases age by 1, until age = 25. When created in other circumstances (player placement/natural generation/harvesting), age is randomly assigned a value from 0~24, with uniform distribution.

Based on the above characteristics, 肥啾 and 镍镍 listed the theoretical expectation of kelp growth and derived the theoretical efficiency. However, graphing the efficiency formula produces an image roughly like this:<p>
![Formula](https://i0.hdslb.com/bfs/article/a850eb3f0fbe2ef73b181e921d8518fdfa5326f4.png)<p>
![Calculation](./markdown_image/CalculationFig_1.png)<p>
Setting aside numerical issues with the calculation results, we can see the graph is a monotonically decreasing curve. This seems to tell players that `the shorter the harvest cycle, the higher the theoretical efficiency per kelp stalk`. Obviously this is impossible, because the calculation ignores an important factor: when the harvest cycle is short enough, the growth gap caused by each harvest is non-negligible. The most obvious point is water flow speed: <u>After a piston breaks kelp, what's left is an air block, and water flow needs 5gt to fill this gap</u>. During these 5gt, kelp cannot grow. Therefore, if the harvest cycle is 10gt, this means **half the time** the kelp farm is running, kelp cannot grow.

## Part 2 - Full Program Construction Process
To compensate for this deficiency and obtain results closer to reality, I decided to add more influencing factors to the calculation. Including:

- **Random Tick Speed**: i.e., /gamerule randomTickSpeed
- **Harvest Cycle**: Harvest cycle
- **Height Limit**: Maximum height kelp can grow to
- **Gap Time**: Time after each harvest during which kelp cannot grow, e.g., water flow speed limits this to a minimum of 5gt
- **Random Tick and Scheduled Tick Order**: 1.14~1.17, random tick phase is before scheduled tick; 1.13.x & 1.17.1, random tick phase is after scheduled tick

Source code for my and ishland's programs is on GitHub. The `main` branch corresponds to my Python implementation of the simulation algorithm, and the `master` branch corresponds to ishland's Java implementation using OpenCL API for GPU-accelerated simulation. Here's the link: https://github.com/Youmiel/KelpSimulator

Based on [Part 1](#part-1---known-information-and-existing-problems), first construct the individual kelp class:<br>
``` python
class Kelp():
    growth_probability = 0.14

    def __init__(self) -> None: # Initialization
        self.init()

    def init(self): # Initialization and reset share the same code
        self.age = random.randint(0,24)
        self.start_age = self.age
        # Only need to record initial age and current age to calculate kelp height

    def tick(self): # Calculation after each random tick selects kelp
        if self.age < 25 and random.random() < Kelp.growth_probability:
            self.age += 1

    def harvest(self) -> int: # Harvest, returns number of kelp obtained
        result = self.age - self.start_age
        self.init()
        return result

    def reset(self): # Reset state
        self.harvest()
```
Then the kelp farm class composed of individual kelp:
```python
class KelpFarm():
    segement_size = 16**2 # Simulate max 256 kelp per chunk
    subchunk_size = 16**3 # Subchunk size, for calculating random ticks
    def __init__(self, kelps: dict, config: dict) -> None:
        # Initialization
        # ...
        # Code omitted due to length
        pass

    def task_name(self) -> str:
        # Task name generated from input config, for stdout output
        return self.task_name

    def start(self) -> tuple:
        # Start calculation
        lo = multiprocessing.Lock()
        lo.acquire()
        print('Start simulating:' + self.task_name + '\n', end='')
        lo.release()
        return self.simulate()

    def simulate(self) -> tuple:
        # Simulate and return final results
        for self.gametick in range(self.test_time):
            self.tick()
        eff = decimal.Decimal(self.item_count) /\
                decimal.Decimal(self.kelp_count * self.test_time / 72000.)
        return(config, eff)

    def tick(self):
        # Operations per gt, including random ticks, scheduled ticks, harvesting, etc.
        # ...
        # Code omitted due to length
        pass
```
Then the main function, basically just an outline:
```python
load_config("./config-multiprocess.json")
init()
start()
show_result()
```
Initially I was overconfident about my simulation program, thinking this calculation task was a piece of cake, so I only used single-threaded operation. However, the actual result was "one core struggling, nineteen cores watching":
![1core](./markdown_image/1core.png)

Eventually I had to use multiprocessing for parallel processing to speed up calculations. Python's parallel processing is divided into multi-threading and multi-processing, but Python's multi-threading is still handled by one process, so multiprocessing was chosen here to take advantage of multi-core CPUs:
```python
import multiprocessing

load_config("./config-multiprocess.json")
init()
with multiprocessing.Pool(processes=config['process_count']) as pool:
    start(pool)
show_result()
```
Other parts of the code won't be posted here; interested readers can check GitHub themselves.

Later, ishland rewrote the simulation program in Java and used OpenCL to call GPU-accelerated computing, with even better calculation speed. See: https://github.com/Youmiel/KelpSimulator/tree/master

## Part 3 - Data Analysis and Results Presentation
After completing the simulation program, I simulated harvest cycles from 10gt (0.5 seconds) to 72000gt (1 hour) in 10gt steps, height limits from 1~25, totaling 180,000 scenarios. Each simulation ran for 1000 hours with 2048 test kelp. Data processing and display used Python's numpy and matplotlib modules.

Direct plotting of test data still shows fluctuations when zoomed in, but the curve drops rapidly when harvest interval approaches 10gt, roughly matching expectations:
![RawData](./markdown_image/RawData.png)

Using `numpy.polynomial.Polynomial.fit()` for curve fitting (using least squares fitting), resulting in the following curve and an extremum:
![RawDataFit](./markdown_image/RawDataFit.png)

Processing all 25 height limit cases (only showing portions near each curve's extremum), we can see that when the height limit exceeds a certain value, the plotted curves almost overlap:
![RawDataFit++](./markdown_image/RawDataFit++.png)

After extracting the 25 extremum points for different height limits to form a chart, we can see that except for the first and second points, the remaining extrema are almost densely distributed within a limited range. Also, the **growth rate** of **unit efficiency** as height limit increases is almost 0 after height 3 (negative values and fluctuations are due to insufficient test time, not precise data):
![MaxPoints](./markdown_image/MaxPoints.png)
![Increament](./markdown_image/Increament.png)

## Part 4 - Research Summary
- The simulation scenario is limited to kelp farms without detection where harvesting only uses piston pushing, without using dispensers to fill water the next gt after piston retraction (source of this idea: Fallen_Breath)
- Designing kelp farms shouldn't blindly shorten harvest intervals to pursue high yield. When harvest interval is too small, efficiency drops dramatically.
- Height limits greater than 3 usually don't provide more efficiency per kelp, except for increasing farm volume and materials.
- At height limit 1, the most efficient harvest cycle is about 16s; at height limit 2, about 53s; at height limits of 3 or more, the most efficient harvest cycle is roughly in the 75~95s range.
