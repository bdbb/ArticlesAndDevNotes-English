# Minecraft Java Edition 1.17~1.18 Moss Block Properties Summary
*Some content in this article can also be found on the wiki, and indeed some parts I referenced from the wiki, but the wiki's recorded content sometimes differs from actual behavior.*

*The depth of this article's content gradually increases. When you find certain content incomprehensible, please pause reading, as the later content won't be what you need at that point. Feel free to return when you have sufficient knowledge and truly need this information.*

*Article content corresponds to Java Edition 1.17~1.18. Future versions may have changes that require further verification.*

![Moss_Block_JE1](./img/Moss_Block_JE1.png)
## Common Block Properties

*Most can be seen using /info (carpet command, enable with /carpet commandInfo true).*

Property Name | Status
-|-
Light Source | No
Light Transparency | Opaque
Suffocation | Yes
Flammable | No
Burns Away | No
Affected by Random Tick | No
Spawnable Surface | Yes
Redstone Signal Source | No
Conducts Signal/Wire Locking/Container Locking (isNormalCube) | Yes
Material Category | Moss (MOSS), only moss block uses this material category
Best Mining Tool | Hoe, stone hoe or better can break instantly
Mining Hardness/Blast Resistance | Mining Hardness: 0.1, Blast Resistance: 0.1
Collision Box/Block Surface | Full collision box, is a full block; full block selection box
Piston Interaction | Can be pushed and broken by pistons, cannot be pulled
Map Display Color | Green, same color as green wool, green shulker box, green stained glass, green glazed terracotta, green concrete, etc.

## Attachable Blocks
### Controlled by Block Tags
- All blocks that can be attached to blocks with the `#minecraft:dirt` tag.
  - Various saplings
  - Dead bush
  - Sugar cane
  - Bamboo
  - Berry bush
  - Small/large flowers
  - Grass/tall grass
  - Mushrooms (when light level allows)
  - Melon/pumpkin stems consider it a valid result position

### Others (usually block surfaces)
- All blocks that can attach to complete surfaces
- Carpets and similar blocks that only need support from below
- Signs, paintings, item frames, glow item frames, banners
  - The above five require the attached block to be a solid block, determined by the block's material category (`((Material)obj).isSolid()`)
  - https://minecraft.fandom.com/wiki/Solid_block

## Sources (Excerpted from Minecraft Wiki)
### Natural Generation
- Moss blocks naturally generate in the Lush Caves biome.

### Spreading
- Using bone meal on a moss block with **air above** will convert various surrounding blocks to moss blocks. See [#Spreading](#spreading)

### Trading
- Wandering traders have a `5/total tier-1 trades` probability to sell 2 moss blocks for 1 emerald.
  - In 1.17.1, this is 5/62
- Attached is the source code from 1.17.1 yarn-mapping; those with ability can verify using my comments

```java
//net.minecraft.entity.passive.WanderingTraderEntity#fillRecipes()
@Override
protected void fillRecipes() {
    TradeOffers.Factory[] lvs = (TradeOffers.Factory[])TradeOffers.WANDERING_TRADER_TRADES.get(1);
        //Tier 1 trades, 62 total
    TradeOffers.Factory[] lvs2 = (TradeOffers.Factory[])TradeOffers.WANDERING_TRADER_TRADES.get(2);
        //Tier 2 trades, 6 total
    if (lvs == null || lvs2 == null) {
        return;
    }
    TradeOfferList lv = this.getOffers();
    this.fillRecipesFromPool(lv, lvs, 5); //Select 5 non-repeating from tier 1 trades
    int i = this.random.nextInt(lvs2.length);
    TradeOffers.Factory lv2 = lvs2[i]; //Randomly select 1 from tier 2 trades
    TradeOffer lv3 = lv2.create(this, this.random);
    if (lv3 != null) {
        lv.add(lv3);
    }
}

//net.minecraft.entity.passive.MerchantEntity#fillRecipesFromPool()
protected void fillRecipesFromPool(TradeOfferList recipeList, TradeOffers.Factory[] pool, int count) {
    HashSet<Integer> set = Sets.newHashSet(); //HashSet, elements don't repeat
    if (pool.length > count) {
        while (set.size() < count) { //Random selection while set size is less than selection count
            set.add(this.random.nextInt(pool.length));
        }
    } else { //When selection count exceeds available count, add entire trade pool to set
        for (int j = 0; j < pool.length; ++j) {
            set.add(j);
        }
    }
    for (Integer integer : set) { //Add selected trade items to merchant's trade list one by one
        TradeOffers.Factory lv = pool[integer];
        TradeOffer lv2 = lv.create(this, this.random);
            //This random is only used when trade items involve enchanted items or dyed armor
        if (lv2 == null) continue;
        recipeList.add(lv2);
    }
}
```

### Chest Loot
- Only writing Java Edition's case, as I haven't dealt much with Bedrock Edition and am not clear about Bedrock Edition's chest loot mechanics. I don't know how the wiki determined Bedrock and Java Edition mechanics are the same here. Also, I don't know why the wiki specifically notes Java and Bedrock Editions are the same here, while all preceding content neither states whether they're the same nor which version they're specific to.

Item|Moss Block||
-|-|-
Source|Shipwreck Supply Chest|*Supply chest is the chest at the bow of the shipwreck, common items are food and leather armor, etc.*
Stack Size|1-4|
Probability|42.06%|
Expected Item Count|1.05|= Expected stack size * Probability
Expected Chests|2.4|= 1 / Probability

## Item Processing
### Crafting
- Can be used to craft moss carpet, mossy cobblestone, and mossy stone bricks. This is a more convenient way to obtain mossy cobblestone and mossy stone bricks, since mass-producing moss blocks is easier than mass-producing vines.
  - See https://minecraft.fandom.com/wiki/Moss_Block#Crafting

### Composting
- Placing moss blocks in a composter has a 65% chance to increase the compost level by one. Note that when the composter is empty, any composting material has 100% probability to increase by one level, so the expected bone meal output from N identical items is `N / (6 / compost_probability + 1)`

## Spreading
### Affected Blocks
- All blocks with the `#minecraft:moss_replaceable` tag that have a **complete top surface**. In vanilla datapack:
  - Stone, granite, diorite, andesite, tuff, deepslate
  - Dirt, grass block, podzol, coarse dirt, mycelium, rooted dirt, moss block
    - Yes, you read that right, "I transform into myself."
- Block tag files from vanilla datapack:
```json
//moss_replaceable.json
{
  "replace": false,
  "values": [
    "#minecraft:base_stone_overworld",
    "#minecraft:cave_vines",
    "#minecraft:dirt"
  ]
}
```
```json
//base_stone_overworld.json
{
  "replace": false,
  "values": [
    "minecraft:stone",
    "minecraft:granite",
    "minecraft:diorite",
    "minecraft:andesite",
    "minecraft:tuff",
    "minecraft:deepslate"
  ]
}
```
```json
//cave_vines.json
{
  "replace": false,
  "values": [
    "minecraft:cave_vines_plant",
    "minecraft:cave_vines"
  ]
  /*
  These two blocks are useless, because cave vines' top surface is incomplete.
  They're in the tag because moss_replaceable is referenced by lush_ground_replaceable,
  which is used for Lush Caves generation
  */
}
```
```json
//dirt.json
{
  "replace": false,
  "values": [
    "minecraft:dirt",
    "minecraft:grass_block",
    "minecraft:podzol",
    "minecraft:coarse_dirt",
    "minecraft:mycelium",
    "minecraft:rooted_dirt",
    "minecraft:moss_block"
  ]
}
```
### Affected Range
- The moss block spreading process reuses code related to world decoration generation. Core logic is in `net.minecraft.world.gen.feature.VegetationPatchFeature` and `net.minecraft.world.gen.feature.SimpleBlockFeature` (yarn mapping). Both generating moss/clay areas on the top and bottom of Lush Caves call this logic, with different parameters.
- Horizontal Range:
  - The overall horizontal range is randomly one of four rectangles: 5×5, 5×7, 7×5, or 7×7, where:
    - Transformation probability at the four corners is 0
    - Blocks on the rectangle's edge (except corners) have transformation probability of 0.75
    - Center transformation probability is 0, because the center is already a moss block
  - Visualized as follows:
    - ![4kind](./img/4kind.png)
  - Combining all four cases produces this heat map:
    - ![4kind+](./img/4kind+.png)
  - This is a result of moss block spreading on a stone platform. Glass marks the moss block that was bone mealed, white concrete marks the four corners of the rectangle (probability 0), and red concrete at the edge is the unconverted part that hit the (1 - 0.75) probability:
  ![moss_spread_example_h](./img/moss_spread_example_h.png)
- Vertical Range:
  - ![moss_volume](./img/moss_volume.png)
  - After determining the horizontal spread range, for each column in the horizontal position, search for suitable spreading positions within an 11-block range (5 blocks above and 5 blocks below, totaling 11 blocks) centered on the moss block's height
    - If there's a non-air block one block above the moss block's height, select the highest non-air block within 5 blocks above
    - If one block above the moss block's height is an air block, select the highest non-air block at or within 5 blocks below the moss block's height
- If the block at the selected position has the moss_replaceable tag, has a complete top surface, and has air above, replace that position with a moss block
  - Example: After adding oak trapdoor to the `#minecraft:moss_replaceable` tag via datapack:
    ![moss_trapdoor](./img/moss_trapdoor.png)
  - Closed trapdoors have a complete top surface and are replaced with moss blocks; open trapdoors cannot be replaced because their top surface is incomplete
- For all successfully converted blocks, generate vegetation cover on top according to weight configuration
- Example:
  ![moss_spread_example_v](./img/moss_spread_example_v.png)

  Block Number | Result | Reason
  | - | - | - |
  A | Spread | One block above moss block height is air, A is the highest non-air block at or within 5 blocks below moss block height
  B | No Spread | One block above moss block height is air, cannot search upward to B
  C | Spread | Same as A
  D | Spread | One block above moss block height is non-air, search upward to find highest non-air block D
  E | No Spread | One block above moss block height is air, cannot search upward to E
  F | No Spread | Same column prioritizes finding D, ignoring F
  G | Spread | One block above moss block height is air, didn't search upward to E, G is the highest non-air block at or within 5 blocks below moss block height
  H | Spread | One block above moss block height is non-air, search upward, passing through grass block to highest non-air block H
  I | No Spread | One block above moss block height is non-air, search upward, but there's an air gap one block below I, search interrupted, can only find the stone block two blocks below I
### Vegetation Cover Generation
- This section's probabilities were discussed multiple times between me, Nickid2018, and wiki editors. The final table is as follows, same as the one on the wiki.

Probability | Vegetation Type | Weight | Final
-|-|-|-
40% | None (air)| - | 40%
60% | Flowering azalea | 4 | 2.5%
... | Azalea | 7 | 4.375%
... | Moss carpet | 25 | 15.625%
... | Grass (one block tall) | 50 | 31.25%
... | Tall grass (two blocks tall) | 10 | 6.25%

- Special case: If tall grass doesn't have enough space to generate, it generates air instead

## Inference - Bone Meal Farm Based on Moss Spreading
- If we maximize moss spreading range and compost all converted products, roughly how much bone meal can we get?
  - Based on the heat map above, expected moss blocks converted per fertilization is 27
  - According to the vegetation cover generation probability table, expected generation for each vegetation type:
    - Flowering azalea: 27 * 2.5% = 0.675
    - Azalea: 27 * 4.375% = 1.18125
    - Moss carpet: 27 * 15.625% = 4.21875
    - Grass: 27 * 31.25% = 8.4375
    - Tall grass: 27 * 6.25% = 1.6875
- Since moss farm output is usually large, most composters will eventually continuously compost one item type, so we can estimate final output using each product composted individually:

Block | Expected Generation | Product | Drop Probability | Item Compost Probability | Expected Bone Meal Output
-|-|-|-|-|-
Moss block | 27 | Moss block | 100% | 65% | 2.639097744
Flowering azalea| 0.675 | Flowering azalea | 100% | 85% | 0.083759124
Azalea | 1.18125 | Azalea | 100% | 65% | 0.115460526
Moss carpet | 4.21875 | Moss carpet | 100% | 30% | 0.200892857
Grass | 8.4375 | Wheat seeds | 12.5% | 30% | 0.050223214
Tall grass | 1.6875 | Wheat seeds | 12.5% | 30% | 0.010044643
| - | - | **Bone meal** | - | - | 3.099478109 |

- So we can conclude that under ideal conditions, bone meal farms based on moss spreading have an `input/output ratio` of about 1:3.1. Subtracting bone meal consumed during farm operation gives `net output` of `2.1 (bone meal/fertilization)`. The ideal bone meal farm efficiency formula is `Bone meal efficiency (per hour) = 72000 / dispenser activation cycle * 2.1`
  - If moss spreading area can't be fully utilized due to machine design issues, recalculate expected moss block output using the heat map, and subsequent vegetation cover expected output
  - If moss spreading area is exactly half blocked due to machine design issues, product output becomes 1/2 of original, `input/output ratio` becomes 1:1.55, `net output` becomes 0.55, only about 1/4 of ideal. Machine count needed to achieve same bone meal output efficiency becomes 4x the ideal case

- If not considering bone meal consumption and directly outputting products, under ideal conditions each spread has expected product count of 34.340625, efficiency formula is `Total efficiency (per hour) = 72000 / dispenser activation cycle * 34.340625`
  - Ideal efficiency with 30gt clock is 82417.5 (items/hour)

## Inference - Dirt Farm
- Large spruce trees convert blocks with the `#minecraft:dirt` tag below them to podzol when growing, and moss block also has the `#minecraft:dirt` tag
  - Thus there's a dirt regeneration route: Stone -> Moss -> Podzol -> Dirt item (block breaking drops). Compared to previous versions using gravel and dirt to craft coarse dirt then using a hoe to turn it back to dirt, this is easier to automate
    - And once this idea was proposed during 1.17 snapshots, people quickly made prototypes
- Since I don't understand the specific mechanics of spruce generating podzol, I can't provide more information here



# Code Analysis

*For convenience, the deobfuscation mapping used here is 1.17.1 yarn mapping, the deobfuscation mapping maintained by Fabric.*

## How Minecraft Defines Moss Block Spreading Behavior

**This is not an undefined feature**, but intentional. Since 1.16, Mojang has opened many world generation related content to be datapack-configurable, divided into biome, configured_carver, configured_feature, configured_structure_feature, configured_surface_builder, noise_settings, processor, and template_pool categories. Moss block generation in Lush Caves and spreading after using bone meal both belong to the configured_feature category, i.e., **configured world decorations**.

However, it's worth noting that up to the current latest release 1.18.1, modifying the following configuration content doesn't change moss block spreading behavior—it only affects moss patches generated in Lush Caves during world generation.

### Configuration Parameters
- Configuration from vanilla world generation datapack:
```json
//minecraft/worldgen/configured_feature/moss_patch_bonemeal.json
{
  "config": {
    "vegetation_chance": 0.6, //Probability of generating vegetation cover on top of each successfully converted block
    "xz_radius": { //xz axis range, i.e., horizontal spread range
      "type": "minecraft:uniform", //Uniform distribution
      "value": {
        "min_inclusive": 1,
        "max_inclusive": 2
      }
    },
    "extra_edge_column_chance": 0.75, //Generation probability for edge blocks
    "extra_bottom_block_chance": 0.0, //Probability of replacement thickness greater than 1
    "vertical_range": 5, //Vertical search range
    "vegetation_feature": "minecraft:moss_vegetation", //Decoration config used for generating vegetation cover
    "surface": "floor", //Surface to attach to, two types: floor and ceiling, corresponding to cave bottom and top generation
    "depth": 1, //Replacement depth (or thickness), controlled by extra_bottom_block_chance
    "replaceable": "minecraft:moss_replaceable", //Tag that replaced blocks must have
    "ground_state": { //What block to replace with
      "state": {
        "Name": "minecraft:moss_block"
      },
      "type": "minecraft:simple_state_provider"
    }
  },
  "type": "minecraft:vegetation_patch" //World decoration method called, all preceding config items are written for this item's parameter requirements
}

//minecraft/worldgen/configured_feature/moss_vegetation.json
{
  "config": {
    "to_place": {
      "entries": [ //Vegetation list to generate
        {
          "data": {
            "Name": "minecraft:flowering_azalea"
          },
          "weight": 4 //Weight, final probability is (weight/total weight)
        },
        {
          "data": {
            "Name": "minecraft:azalea"
          },
          "weight": 7
        },
        {
          "data": {
            "Name": "minecraft:moss_carpet"
          },
          "weight": 25
        },
        {
          "data": {
            "Name": "minecraft:grass"
          },
          "weight": 50
        },
        {
          "data": {
            "Properties": {
              "half": "lower"
            },
            "Name": "minecraft:tall_grass"
          },
          "weight": 10
        }
      ],
      "type": "minecraft:weighted_state_provider"
    },
    "place_on": [],
    "place_in": [],
    "place_under": []
  },
  "type": "minecraft:simple_block"
}
```

Corresponding source code. Also, `MOSS_PATCH` and `MOSS_PATCH_CEILING` also call `Feature.VEGETATION_PATCH.configure()`:

```java
//net.minecraft.world.gen.feature.ConfiguredFeatures#MOSS_PATCH_BONEMEAL
public static final ConfiguredFeature<VegetationPatchFeatureConfig, ?> MOSS_PATCH_BONEMEAL =
  ConfiguredFeatures.register(
      "moss_patch_bonemeal",
      Feature.VEGETATION_PATCH.configure(
          new VegetationPatchFeatureConfig(
              BlockTags.MOSS_REPLACEABLE.getId(),
              new SimpleBlockStateProvider(
                  Blocks.MOSS_BLOCK.getDefaultState()
              ),
              () -> MOSS_VEGETATION,
              VerticalSurfaceType.FLOOR,
              ConstantIntProvider.create(1),
              0.0f,
              5,
              0.6f,
              UniformIntProvider.create(1, 2),
              0.75f
          )
      )
  );

//net.minecraft.world.gen.feature.ConfiguredFeatures#MOSS_VEGETATION
public static final ConfiguredFeature<SimpleBlockFeatureConfig, ?> MOSS_VEGETATION =
ConfiguredFeatures.register(
    "moss_vegetation",
    Feature.SIMPLE_BLOCK.configure(
        new SimpleBlockFeatureConfig(
            new WeightedBlockStateProvider(
                ConfiguredFeatures.pool()
                  .add(Blocks.FLOWERING_AZALEA.getDefaultState(), 4)
                  .add(Blocks.AZALEA.getDefaultState(), 7)
                  .add(Blocks.MOSS_CARPET.getDefaultState(), 25)
                  .add(Blocks.GRASS.getDefaultState(), 50)
                  .add(Blocks.TALL_GRASS.getDefaultState(), 10)
            )
        )
    )
);
```

You may need to reference the `VegetationPatchFeatureConfig` class constructor to understand:

```java
//net.minecraft.world.gen.feature.VegetationPatchFeatureConfig#VegetationPatchFeatureConfig

/*
* Decompiled with CFR 0.0.6 (FabricMC 437c16e1).
*/
public class VegetationPatchFeatureConfig implements FeatureConfig {
    /*
    ...
    Omitted some json configuration reading related code
    */
    public VegetationPatchFeatureConfig(Identifier replaceable,
                                        BlockStateProvider groundState,
                                        Supplier<ConfiguredFeature<?, ?>> vegetationFeature,
                                        VerticalSurfaceType surface,
                                        IntProvider depth,
                                        float extraBottomBlockChance,
                                        int verticalRange,
                                        float vegetationChance,
                                        IntProvider horizontalRadius,
                                        float extraEdgeColumnChance) {
        this.replaceable = replaceable;
        this.groundState = groundState;
        this.vegetationFeature = vegetationFeature;
        this.surface = surface;
        this.depth = depth;
        this.extraBottomBlockChance = extraBottomBlockChance;
        this.verticalRange = verticalRange;
        this.vegetationChance = vegetationChance;
        this.horizontalRadius = horizontalRadius;
        this.extraEdgeColumnChance = extraEdgeColumnChance;
    }
}
```

### Call Process When Spreading via Bone Meal

When using bone meal on a moss block, the isFertilizable() method is called first, checking whether air is above the moss block. Bone meal can only be properly used when there's air above.

The grow() method is where the moss block spreading logic is actually called:
```java
//net.minecraft.block.MossBlock

/*
 * Decompiled with CFR 0.0.6 (FabricMC 437c16e1).
 */
public class MossBlock extends Block implements Fertilizable {
    public MossBlock(AbstractBlock.Settings arg) {//...}

    @Override
    public boolean isFertilizable(BlockView world, BlockPos pos, BlockState state, boolean isClient) {
        return world.getBlockState(pos.up()).isAir();
    }

    @Override
    public boolean canGrow(World world, Random random, BlockPos pos, BlockState state) {//...}

    @Override
    public void grow(ServerWorld world, Random random, BlockPos pos, BlockState state) {
        Feature.VEGETATION_PATCH.generate(
            new FeatureContext<VegetationPatchFeatureConfig>(
                world,
                world.getChunkManager().getChunkGenerator(),
                random,
                pos.up(),
                ConfiguredFeatures.MOSS_PATCH_BONEMEAL.getConfig()
            )
        );
    }
}
```

Both the earlier configuration and grow() here reference an object named `VEGETATION_PATCH`. What is it?

```java
//net.minecraft.world.gen.feature.Feature#VEGETATION_PATCH
public static final Feature<VegetationPatchFeatureConfig> VEGETATION_PATCH =
    Feature.register(
        "vegetation_patch",
        new VegetationPatchFeature(VegetationPatchFeatureConfig.CODEC)
    );
```

This line registers the `VegetationPatchFeature` class as a terrain decorator named vegetation_patch under the minecraft namespace, for calling. Lush Caves moss block generation, moss block spreading, and other mechanics are built on this with different configurations to become the actual in-game content. This also means if you want to use datapacks/mods to create similar landscapes, you can directly configure this decorator with different parameters instead of reinventing the wheel.

Delving further into the `VegetationPatchFeature` class content, the moss spreading logic finally emerges. Since comments are already clear, I won't repeat:

```java
//net.minecraft.world.gen.feature.VegetationPatchFeature

/*
 * Decompiled with CFR 0.0.6 (FabricMC 437c16e1).
 */
public class VegetationPatchFeature extends Feature<VegetationPatchFeatureConfig> {
    public VegetationPatchFeature(Codec<VegetationPatchFeatureConfig> codec) {
        super(codec);
    }

    @Override
    public boolean generate(FeatureContext<VegetationPatchFeatureConfig> context) {
        StructureWorldAccess lv = context.getWorld();
        VegetationPatchFeatureConfig lv2 = context.getConfig();
        Random random = context.getRandom();
        BlockPos lv3 = context.getOrigin(); //Reference position, one block above moss block, temporarily designated as (x0, y0, z0) in comments
        Predicate<BlockState> predicate = VegetationPatchFeature.getReplaceablePredicate(lv2);
        int i = lv2.horizontalRadius.get(random) + 1;
            //x-axis radius, for moss block spreading, is 2 or 3
        int j = lv2.horizontalRadius.get(random) + 1;
            //z-axis radius, for moss block spreading, is 2 or 3
        Set<BlockPos> set = this.placeGroundAndGetPositions(lv, lv2, random, lv3, predicate, i, j);
            //Generate bottom blocks
        this.generateVegetation(context, lv, lv2, random, set, i, j);
            //Generate vegetation cover
        return !set.isEmpty();
    }

    protected Set<BlockPos> placeGroundAndGetPositions(StructureWorldAccess world, VegetationPatchFeatureConfig config, Random random, BlockPos pos, Predicate<BlockState> replaceable, int radiusX, int radiusZ) {
        BlockPos.Mutable lv = pos.mutableCopy();
        BlockPos.Mutable lv2 = lv.mutableCopy();
        Direction lv3 = config.surface.getDirection();
        Direction lv4 = lv3.getOpposite();
        HashSet<BlockPos> set = new HashSet<BlockPos>();
        for (int k = -radiusX; k <= radiusX; ++k) {//Overall, traversing all columns in a (radiusX,radiusZ) sized horizontal rectangle
            boolean bl = k == -radiusX || k == radiusX; //Whether at x-axis interval boundary
            for (int l = -radiusZ; l <= radiusZ; ++l) {
                int m;
                boolean bl5;
                boolean bl2 = l == -radiusZ || l == radiusZ; //Whether at z-axis interval boundary
                boolean bl3 = bl || bl2; //Whether at x-axis or z-axis interval boundary, i.e., rectangle's outermost ring
                boolean bl4 = bl && bl2; //Whether at both x-axis and z-axis interval boundaries, i.e., rectangle's corner
                boolean bl6 = bl5 = bl3 && !bl4;
                if (bl4 || bl5 && (config.extraEdgeColumnChance == 0.0f || random.nextFloat() > config.extraEdgeColumnChance)) continue;
                    /*Three cases skip (x0+k, z0+l) position generation:
                        1. At rectangle's corner
                        2. At rectangle's edge, and extraEdgeColumnChance is 0
                        3. At rectangle's edge, and (0~1 random float) > extraEdgeColumnChance,
                                i.e., (1 - extraEdgeColumnChance) probability of not generating
                                For moss block spreading, this is 0.25
                    */
                lv.set(pos, k, 0, l);// Add (k, 0, l) offset from reference point
                for (m = 0; world.testBlockState(lv, AbstractBlock.AbstractBlockState::isAir) && m < config.verticalRange; ++m) {
                    lv.move(lv3); //From (x0+k, y0, z0+l) position, search verticalRange blocks in direction determined by surface (for moss block spreading, downward), stop at first non-air block, call it (k, y1, l)
                                        //Edge case: all air
                }
                for (m = 0; world.testBlockState(lv, arg -> !arg.isAir()) && m < config.verticalRange; ++m) {
                    lv.move(lv4); //From (x0+k, y1, z0+l) position, search verticalRange blocks in opposite direction (for moss block spreading, upward), stop at first air block, call it (k, y2, l)
                }
                lv2.set((Vec3i)lv, config.surface.getDirection()); //Move selected position one block, for moss block spreading, one block down, i.e., (x0+k, y2-1, z0+l)
                BlockState lv5 = world.getBlockState(lv2);
                if (!world.isAir(lv) || !lv5.isSideSolidFullSquare(world, lv2, config.surface.getDirection().getOpposite())) continue;
                    // Whether selected position is non-air and corresponding surface is complete (for moss block spreading, top surface), if not, skip
                int n = config.depth.get(random) + (config.extraBottomBlockChance > 0.0f && random.nextFloat() < config.extraBottomBlockChance ? 1 : 0);
                    // Random conversion depth
                BlockPos lv6 = lv2.toImmutable();
                boolean bl62 = this.placeGround(world, config, replaceable, random, lv2, n);
                    // Place blocks
                if (!bl62) continue; //If replacement unsuccessful, skip recording
                set.add(lv6); //Add selected position to block position record set
            }
        }
        return set; //Return record set for subsequent vegetation cover generation
    }

    protected void generateVegetation(FeatureContext<VegetationPatchFeatureConfig> context,
                                    StructureWorldAccess world,
                                    VegetationPatchFeatureConfig config,
                                    Random random, Set<BlockPos> positions,
                                    int radiusX,
                                    int radiusZ) {
        for (BlockPos lv : positions) {
            if (!(config.vegetationChance > 0.0f) || !(random.nextFloat() < config.vegetationChance)) continue;
                //(1 - vegetationChance) probability of skipping (not generating), for moss block spreading, 40%
            this.generateVegetationFeature(world, config, context.getGenerator(), random, lv);
                //Generate vegetation cover according to configured weights
        }
    }

    protected boolean generateVegetationFeature(StructureWorldAccess world, VegetationPatchFeatureConfig config, ChunkGenerator generator, Random random, BlockPos pos) {
        return config.vegetationFeature.get().generate(world, generator, random, pos.offset(config.surface.getDirection().getOpposite()));
                //Generate vegetation cover according to configured weights, reference point is one block in opposite direction of surface from selected position, for moss block spreading, one block above
    }

    protected boolean placeGround(StructureWorldAccess world, VegetationPatchFeatureConfig config, Predicate<BlockState> replaceable, Random random, BlockPos.Mutable pos, int depth) {
        for (int j = 0; j < depth; ++j) { //Replace one by one starting from reference point
            BlockState lv2;
            BlockState lv = config.groundState.getBlockState(random, pos); //Replacement block type
            if (lv.isOf((lv2 = world.getBlockState(pos)).getBlock())) continue; //Skip if same block type
            if (!replaceable.test(lv2)) { //Check if selected position's block meets conditions, i.e., is in allowed block set
                return j != 0; //If same block encountered, terminate this replacement process
                //Return whether at least one block was successfully replaced
            }
            world.setBlockState(pos, lv, Block.NOTIFY_LISTENERS); //Replace block and update listeners
            pos.move(config.surface.getDirection());
        }
        return true; //All replaced, return true
    }

    private static Predicate<BlockState> getReplaceablePredicate(VegetationPatchFeatureConfig config) {
        //Generate a predicate based on block tag, for determining if selected block meets replacement requirements
        Tag<Block> lv = BlockTags.getTagGroup().getTag(config.replaceable);
        return lv == null ? state -> true : state -> state.isIn(lv);
    }
}
```

Don't forget `MOSS_VEGETATION` referenced in the configuration, which further references `SIMPLE_BLOCK`:

```java
//net.minecraft.world.gen.feature.Feature#SIMPLE_BLOCK

public static final Feature<SimpleBlockFeatureConfig> SIMPLE_BLOCK =
    Feature.register(
        "simple_block",
        new SimpleBlockFeature(SimpleBlockFeatureConfig.CODEC)
    );
```
```java
//net.minecraft.world.gen.feature.SimpleBlockFeature

/*
 * Decompiled with CFR 0.0.6 (FabricMC 437c16e1).
 */
public class SimpleBlockFeature extends Feature<SimpleBlockFeatureConfig> {
    public SimpleBlockFeature(Codec<SimpleBlockFeatureConfig> codec) {
        super(codec);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public boolean generate(FeatureContext<SimpleBlockFeatureConfig> context) {
        BlockState lv4;
        SimpleBlockFeatureConfig lv = context.getConfig();
        StructureWorldAccess lv2 = context.getWorld();
        BlockPos lv3 = context.getOrigin();
        if (
            !lv.placeOn.isEmpty() && !lv.placeOn.contains(lv2.getBlockState(lv3.down()))
            || !lv.placeIn.isEmpty() && !lv.placeIn.contains(lv2.getBlockState(lv3))
            || !lv.placeUnder.isEmpty() && !lv.placeUnder.contains(lv2.getBlockState(lv3.up()))
            || !(lv4 = lv.toPlace.getBlockState(context.getRandom(), lv3)).canPlaceAt(lv2, lv3)
        )
            return false;
            //Skip if any of placeOn, placeIn, placeUnder conditions met, or block doesn't meet placement conditions
            //Randomly selecting a block and assigning to variable lv4 is written in the if statement, probably a decompilation issue
        if (lv4.getBlock() instanceof TallPlantBlock) { //Special handling for large flowers, tall grass, small dripleaf
            if (!lv2.isAir(lv3.up())) return false; //If upper half has non-air block blocking, don't place
            TallPlantBlock.placeAt(lv2, lv4, lv3, 2);
            return true;
        } else {
            lv2.setBlockState(lv3, lv4, Block.NOTIFY_LISTENERS);
                //Normal blocks, place directly
        }
        return true;
    }
}
```


<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">work</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Youmiel</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.
